def longest_uniform_substring_after_replacement(s: str, k: int) -> int:
    freqs = {}
    highest_freq = max_len = 0
    left = right = 0
    while right < len(s):
        # Update the frequency of the character at the right pointer
        # and the highest frequency for the current window
        freqs[s[right]] = freqs.get(s[right], 0) + 1
        highest_freq = max(highest_freq, freqs[s[right]])
        # Calculate replacements needed for the current window
        num_chars_to_replace = (right - left + 1) - highest_freq
        # Slide the window if the number of replacements needed exceeds
        # 'k'. The right pointer always get advanced,so we just need
        # to advance 'left'
        if num_chars_to_replace > k:
            # Remove the characters at the left pointer from the hash map
            # before advancing the left pointer
            freqs[s[left]] -=1
            left +=1
        # Since the length of the current window increases or stays the
        # same, assign the length of the current window to 'max_len'
        max_len = right - left + 1
        right +=1
    return max_len
